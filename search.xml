<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pipenv的基本使用]]></title>
    <url>%2F2018%2F05%2F30%2FPython%2Fpipenv%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[toc] pipenv 是 Pipfile 主要倡导者、requests 作者 Kenneth Reitz 写的一个命令行工具，主要包含了Pipfile、pip、click、requests和virtualenv。Pipfile和pipenv本来都是Kenneth Reitz的个人项目，后来贡献给了pypa组织。Pipfile是社区拟定的依赖管理文件，用于替代过于简陋的 requirements.txt 文件。Pipfile的基本理念是：Pipfile 文件是 TOML 格式而不是 requirements.txt 这样的纯文本。一个项目对应一个 Pipfile，支持开发环境与正式环境区分。默认提供 default 和 development 区分。提供版本锁支持，存为 Pipfile.lock。click是Flask作者 Armin Ronacher 写的命令行库，现在Flask已经集成了它。 安装安装pipenv 1pip install pipenv 然后将目录更改为包含你的Python项目的文件夹，并启动Pipenv 12cd my_projectpipenv install 这将在项目目录中创建两个新文件Pipfile和Pipfile.lock，如果项目不存在，则为项目创建一个新的虚拟环境。 如果你添加–two或–three标志到上面的最后一个命令，它分别使用Python 2或3来初始化你的项目。 否则将使用默认版本的Python。 新的解释器位置如： C:\Users\AirBook\.virtualenvs\untitled1-Z1OETCoj\Scripts\python.exe如果使用Pycharm进行开发时候，可以使用这个路径进行配置解释器。 管理Python依赖关系安装需要的Python包,比如： 1pip install six 删除指定的Python包,比如： 1pip uninstall six 可以通过更新Pipfile.lock来冻结软件包名称及其版本，以及其依赖关系的列表。 这可以使用lock关键字完成的。 1pipenv lock 如果另一个用户克隆存储库，可以添加Pipfiles到你的Git存储库，这样他们只需要在他们的系统中安装Pipenv，然后键入pipenv install，Pipenv会自动找到Pipfiles，创建一个新的虚拟环境并安装必要的软件包。 管理开发环境通常情况下，开发环境和测试环境的包环境是不一样的，比如开发环境中需要有单元测试包。Pipenv使用–dev标志将两个环境分开，如：pipenv install --dev nose2，使用pipenv install是不会安装nose2包的，使用pipenv install -dev会安装nose2的。 代码运行在工程目录下运行： 1pipenv run python my_project.py 如果你不想每次运行Python时都输入这么多，你可以在shell中设置一个别名，例如在Windows系统下: 1doskey prp = pipenv run python 参考1 https://www.jianshu.com/p/00af447f0005]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pipenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.0 学习笔记]]></title>
    <url>%2F2018%2F01%2F07%2F%E5%89%8D%E7%AB%AF%2FVue%2FVue2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Vue.js2.0 笔记内部指令v-if12345678910111213&lt;body class="native"&gt;&lt;div id="example"&gt; &lt;p v-if="greeting"&gt;Hello&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var exampleVM = new Vue(&#123; el: "#example", data: &#123; greeting: false &#125; &#125;)&lt;/script&gt; v-show12345678910111213&lt;body&gt;&lt;div id="example"&gt; &lt;p v-show="greeting"&gt;Hello&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var exampleVM = new Vue(&#123; el: "#example", data: &#123; greeting: true &#125; &#125;)&lt;/script&gt; v-if和v-show的比较&emsp;&emsp;在切换v-if时候，Vue.js有一个局部编译和卸载过程，因为v-if中模板可能包括数据绑定或子组件，v-id是惰性的，如果初始渲染条件为假，什么也做不做，在条件第一次变为真时，才开始进行局部编译（编译会被缓存起来）。&emsp;&emsp;相比之下，v-show元素始终被编译并保留，只是简单地基于CSS切换。&emsp;&emsp;一般来说，v-if具有更高的切换消耗，而v-show有更高的初始渲染消耗。因此需要频繁的切换，使用v-show比较好。如果运行时条件不大可能变化，使用v-if较好。 v-else1234567891011121314&lt;body&gt;&lt;div id="example"&gt; &lt;p v-if="greeting"&gt;greeting is ok&lt;/p&gt; &lt;p v-else="greeting"&gt;greeting is not ok&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var exampleVM = new Vue(&#123; el: "#example", data: &#123; greeting: false &#125; &#125;)&lt;/script&gt; v-model&emsp;&emsp;v-model指令用来在input、select、text、checkbox、radio等表单控件元素上创建双向数据绑定。根据控件类型v-model自动选择正确的方法更新元素。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body id="example"&gt;&lt;form&gt; 姓名： &lt;input type="text" v-model="data.name" placeholder=""&gt; &lt;br/&gt; 性别： &lt;input type="radio" id="man" value="One" v-model="data.sex"&gt; &lt;label for="man"&gt;男&lt;/label&gt; &lt;input type="radio" id="woman" value="Two" v-model="data.sex"&gt; &lt;label for="woman"&gt;女&lt;/label&gt; &lt;br/&gt; 兴趣： &lt;input type="checkbox" id="book" value="book" v-model="data.interest"&gt; &lt;label for="book"&gt;阅读&lt;/label&gt; &lt;input type="checkbox" id="swim" value="swim" v-model="data.interest"&gt; &lt;label for="swim"&gt;游泳&lt;/label&gt; &lt;input type="checkbox" id="game" value="game" v-model="data.interest"&gt; &lt;label for="game"&gt;游戏&lt;/label&gt; &lt;input type="checkbox" id="song" value="song" v-model="data.interest"&gt; &lt;label for="song"&gt;唱歌&lt;/label&gt; &lt;br/&gt; 身份： &lt;select v-model="data.identity"&gt; &lt;option value="teacher" selected&gt;教师&lt;/option&gt; &lt;option value="doctor"&gt;医生&lt;/option&gt; &lt;option value="lawyer"&gt;律师&lt;/option&gt; &lt;/select&gt; &lt;br/&gt;&lt;/form&gt;&lt;/body&gt;&lt;script&gt; var exampleVM = new Vue(&#123; el: 'example', data: &#123; name: '', sex: '', interest: [], identity: '' &#125; &#125;)&lt;/script&gt; 注1：v-model在input事件中同步输入框的值和数据，如果要伴随时间改变而不是同步改变的话，可以参考如下代码：1234567891011121314&lt;body&gt;&lt;div id="example"&gt; &lt;input v-model.lazy="name"&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var a = new Vue(&#123; el: "#example", data: &#123; name: "输入框外点击鼠标显示输入内容" &#125; &#125;)&lt;/script&gt; 注2：v-moel可以对输入框的内容进行trim操作，具体如下代码：1234567891011121314&lt;body&gt;&lt;div id="example"&gt; &lt;input v-model.trim="name"&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var a = new Vue(&#123; el: "#example", data: &#123; name: " 前后都有空格 " &#125; &#125;)&lt;/script&gt; v-for当使用v-for时，v-model不再生效。&lt;input v-for=&quot;str in strings&quot; v-model=&quot;str&quot;&gt;123456789101112131415161718192021222324&lt;body&gt;&lt;div id="example"&gt; &lt;li v-for="(item,index) in items"&gt; 序号：&#123;&#123;index&#125;&#125; 工号：&#123;&#123;item.id&#125;&#125; 姓名：&#123;&#123;item.msg&#125;&#125; &lt;/li&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var a = new Vue(&#123; el: "#example", data: &#123; items: [ &#123; id: '001', msg: "张三" &#125;, &#123; id:'002', msg: "李四" &#125;, ] &#125; &#125;)&lt;/script&gt; v-html12345678910111213&lt;body&gt;&lt;div id="example" v-html="html"&gt; &#123;&#123;html&#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var a = new Vue(&#123; el: "#example", data: &#123; html:"&lt;li&gt;这是一个innerHtml&lt;/li&gt;" &#125; &#125;)&lt;/script&gt; 注：不建议在网站上直接动态渲染任意HTML片段，这样很容易导致XSS攻击。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>VueJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker镜像的基本操作]]></title>
    <url>%2F2017%2F12%2F03%2FDocker%2FDocker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文主要记录了笔者实践《Docker技术入门与实践》过程中做的一些笔记，笔记内容主要是Docker镜像的基本操作。 获取镜像1sudo docker pull [server]/imagename[:tag] 如果不指定tag，会默认使用latest标签,默认服务器是registry.hub.docker.com,也可以使用其他注册服务器进行pull，例如DockerPool社区的镜像源dl.dockerpool.com下载最新的镜像。例如: 1sudo docker pull dl.dockerpool.com/ubuntu:14.04 查看镜像信息1234sudo docker images&gt;&gt;REPOSITORY TAG IMAGE_ID CREATED SIZEubuntu 14.04 20c44cd7596f 2 weeks ago 123 MB 为镜像打TAG1sudo docker tag ubuntu:14.04 ubuntu:mytag tag标签是指向了同一个镜像，只是镜像的别名而已，标签起到了引用和快捷方式的作用。通过sudo docker images查看镜像：123REPOSITORY TAG IMAGE_ID CREATED SIZEubuntu 14.04 20c44cd7596f 2 weeks ago 123 MBubuntu mytag 20c44cd7596f 2 weeks ago 123 MB 可以通过sudo docker inspect REPOSITORY:TagName或者sudo docker inspect REPOSITORY:Image_ID查看镜像的详细信息。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889[ &#123; "Id": "sha256:20c44cd7596ff4807aef84273c99588d22749e2a7e15a7545ac96347baa65eda", "RepoTags": [ "ubuntu:14.04", "ubuntu:latest", "ubuntu:mytag" ], "RepoDigests": [ "ubuntu@sha256:7c67a2206d3c04703e5c23518707bdd4916c057562dd51c74b99b2ba26af0f79" ], "Parent": "", "Comment": "", "Created": "2017-11-17T21:59:25.014645802Z", "Container": "e5f1a9df75b86a5d803eaf6f3fed6a0f8ef5fbf15a6c5039df087e4348ed8171", "ContainerConfig": &#123; "Hostname": "e5f1a9df75b8", "Domainname": "", "User": "", "AttachStdin": false, "AttachStdout": false, "AttachStderr": false, "Tty": false, "OpenStdin": false, "StdinOnce": false, "Env": [ "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" ], "Cmd": [ "/bin/sh", "-c", "#(nop) ", "CMD [\"/bin/bash\"]" ], "ArgsEscaped": true, "Image": "sha256:b5771e7d8dcc594b886dbdd6a9c3de60d45252ca657dfdff6e1d996728dfa2cd", "Volumes": null, "WorkingDir": "", "Entrypoint": null, "OnBuild": null, "Labels": &#123;&#125; &#125;, "DockerVersion": "17.06.2-ce", "Author": "", "Config": &#123; "Hostname": "", "Domainname": "", "User": "", "AttachStdin": false, "AttachStdout": false, "AttachStderr": false, "Tty": false, "OpenStdin": false, "StdinOnce": false, "Env": [ "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" ], "Cmd": [ "/bin/bash" ], "ArgsEscaped": true, "Image": "sha256:b5771e7d8dcc594b886dbdd6a9c3de60d45252ca657dfdff6e1d996728dfa2cd", "Volumes": null, "WorkingDir": "", "Entrypoint": null, "OnBuild": null, "Labels": null &#125;, "Architecture": "amd64", "Os": "linux", "Size": 122792927, "VirtualSize": 122792927, "GraphDriver": &#123; "Name": "aufs", "Data": null &#125;, "RootFS": &#123; "Type": "layers", "Layers": [ "sha256:788ce2310e2fdbbf81fe21cbcc8a44da4cf648b0339b09c221abacb 4cd5fd136", "sha256:aa4e47c4511638484cd5d95eadd7a8e4da307375ba31ff50d47aa9065dce01e0", "sha256:b3968bc26fbd527f214f895aeef940a6930c62d853fe8b12bd479f0b53518150", "sha256:c9748fbf541d3e043521e165b015d45825de33c00a8acb037443cfbd0cb5e677", "sha256:2f5b0990636a87f1557d64ba39808dcd64031328b2a159c5805115b8e725bbbc" ] &#125; &#125;] 上面返回的JSON信息太多，如果只需要其中部分内容，可以使用-f参数来指定，例如获取Architecture信息：sudo docker inspect -f .Architecture ubuntu:14.04返回内容：amd64 删除镜像1sudo docker rmi REPOSITORY:TagName 当镜像只剩下一个标签时候，使用此命令会彻底删除该镜像。 创建镜像创建镜像有三种方式：基于已有镜像的容器创建、基于本地模板导入、基于Dockerfile创建。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过函数指针进行初始化]]></title>
    <url>%2F2017%2F09%2F07%2F%E5%B5%8C%E5%85%A5%E5%BC%8F%2F%E7%BC%96%E7%A8%8B%2F%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[12345678910111213141516typedef void (*Init_board)(void);void Init_function(void);const Init_board Init_Sequnce[] = &#123; Init_function, NULL,&#125;;int Funs_Init(void)&#123; const Init_board *call = Init_Sequnce; for(; *call; ++call) (*call)(); return 0;&#125;]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>函数指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梯度下降(吴恩达公开课笔记)]]></title>
    <url>%2F2017%2F09%2F03%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-%E5%90%B4%E6%81%A9%E8%BE%BE%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0%2F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-%E5%90%B4%E6%81%A9%E8%BE%BE%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[梯度下降思想&emsp;&emsp;梯度下降背后的思想是：开始随机选取一个参数的组合$({\theta}_{0},{\theta}_{1},…,{\theta}_{n})$，计算代价函数，然后虚招下一个能让代价函数下降最多的参数组合。一直迭代下去直到找到一个局部最小值停止。因为并没有遍历所有的参数组合，所以不能确定局部最小值就是去全局最小值，如果代价函数具有多个极值点，那么选择不同的初始参数组合，可能会找到不同的局部最小值。 参数更新&emsp;&emsp;当参数只有两个的时候（一个特征）,代价函数为$J({\theta}_{0},{\theta}_{1})$。&emsp;&emsp;repeat until convergence: $${ {\theta}_{j} := {\theta}_{j} - \alpha\frac{\partial}{\partial{\theta}_{j} }J({\theta}_{0},{\theta}_{1}) } \quad for(j=0\quad and\quad j=1)$$&emsp;&emsp;$temp0:={\theta}_{0}-\alpha\frac{\partial}{\partial{\theta}_{0} }J({\theta}_{0},{\theta}_{1})$&emsp;&emsp;$temp1:={\theta}_{1}-\alpha\frac{\partial}{\partial{\theta}_{1} }J({\theta}_{0},{\theta}_{1})$&emsp;&emsp;${\theta}_{0}:=temp0$&emsp;&emsp;${\theta}_{1}:=temp1$&emsp;&emsp;其中$alpha$是学习率，学习率决定了代价函数下降的大小。在批量梯度下降中，每一次都同时让所有的参数都减去学习速率乘以代价函数的偏导数。 批量梯度下降下面的h(x)是要拟合的函数，J(theta)损失函数，theta是参数，要迭代求解的值，theta求解出来了那最终要拟合的函数h(theta)就出来了。其中m是训练集的记录条数，j是参数的个数。（1）将J(theta)对theta求偏导，得到每个theta对应的的梯度（2）由于是要最小化风险函数，所以按每个参数theta的梯度负方向，来更新每个theta（3）从上面公式可以注意到，它得到的是一个全局最优解，但是每迭代一步，都要用到训练集所有的数据，如果m很大，那么可想而知这种方法的迭代速度！！所以，这就引入了另外一种方法，随机梯度下降。 随机梯度下降（1）上面的风险函数可以写成如下这种形式，损失函数对应的是训练集中每个样本的粒度，而上面批量梯度下降对应的是所有的训练样本：（2）每个样本的损失函数，对theta求偏导得到对应梯度，来更新theta（3）随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本，就已经将theta迭代到最优解了，对比上面的批量梯度下降，迭代一次需要用到十几万训练样本，一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。 两种梯度下降对比批量梯度下降&emsp;&emsp;最小化所有训练样本的损失函数，使得最终求解的是全局的最优解，即求解的参数是使得风险函数最小。 随机梯度下降&emsp;&emsp;最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>梯度下降</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间序列算法]]></title>
    <url>%2F2017%2F09%2F02%2F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95%2F%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%AE%97%E6%B3%95%2F%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、时间序列预处理 &emsp;&emsp;得到一个观测序列之后，要分析检验序列的随机性和平稳性。两个重要的检验称为序列的预处理。对于不同类型的序列需要采用不同的分析方法。 对于纯随机序列，又称白噪声序列，序列各个观测值之间没有任何关系，序列是完全无序的随机波动，则可以不用对序列继续分析。因为白噪声序列是没有任何信息可以提取的平稳序列。 对于平稳非白噪声序列，它的均值和方差是常数。目前已经有一套非常成熟的平稳序列的建模方法。通常是建议一个线性模型来拟合序列的发展。ARMA是最常用的平稳序列拟合模型。 对于非平稳序列，由于序列本身的均值和方差不稳定，处理方法一般是==将其转为平稳序列==，然后采用平稳序列的模型进行分析。对于非平稳序列，经过差分之后具有平稳性则称差分平稳序列，对于差分平稳序列可以使用ARMA模型对其进行分析。 1.1 平稳性检验&emsp;&emsp;平稳性检验主要有两种方法：基于时序图和自相关图做出判断的方法，该方法简单方便，应用广泛，但是具有主观性。另一种方法是构造检验统计量进行验证，该方法最常用的方法是单位根检测。 1.1.1 时序图检验&emsp;&emsp;平稳序列的时序图表现出始终在一个常数附近波动，波动范围有界。如果时序图有明显的趋势性或者周期性通常是非平稳序列。 1.1.2 自相关图检验&emsp;&emsp;平稳序列具有短周期相关性，这性质表明平稳序列通常只有近期的序列值对当前值有明显的影响，随着延迟时间加长，自相关系数会衰减到0，并在0附近随机波动。而对于非平稳序列，自相关系数会衰减缓慢。通过Matlab进行仿真：123456789101112fs=500;t=1/500:1/500:1;f=5;r=randn(1,fs)*0.2;y=sin(2*pi*t*f);ycorr=xcorr(y,y);rcorr=xcorr(r,r);subplot(211);plot(t,y);title('非平稳序列时序图')subplot(212);plot(ycorr);title('非平稳序列自相关图')figuresubplot(211);plot(t,r);title('平稳序列时序图')subplot(212);plot(rcorr);title('平稳序列时序图') 1.1.3 单位根检测&emsp;&emsp;对序列是否具有单位根进行检测，如果存在单位根，则是非平稳序列，反之，是平稳序列。单位根检测有很多种方法。此处主要介绍：DF检测(Dicky-Fuller Test)和ADF检测。 1.2 纯随机性检测&emsp;&emsp;纯随机性检验也称为白噪声检验，一般用构造的统计量来检验序列的纯随机性，常用的统计量有Q统计量和LB统计量。&emsp;&emsp;序列值之间的变异是绝对的，但是相关性是偶然的，则可以做如下假设： &emsp;&emsp;- 原假设：延迟期数不大于$m$期的序列值是相互独立的。 &emsp;&emsp;- 备用假设：延时期数不大于$m$期的序列值是相关的。 &emsp;&emsp;数学语言描述： &emsp;&emsp;${H}_{0}$:${\rho}_{1}={\rho}_{2}=…={\rho}_{m},\forall m\geq1$ &emsp;&emsp;${H}_{1}$:至少存在某个${\rho}_{k}\neq0,\forall m\geq1,k\leq m$]]></content>
      <categories>
        <category>数字信号处理</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>时间序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习简介]]></title>
    <url>%2F2017%2F09%2F02%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1、机器学习三要素 1.1 任务&emsp;&emsp;机器学习的任务有很多，其中两种最经典的任务就是监督学习和无监督学习。其中监督学习主要是对事物进行预测，预测一般包括分类和回归。而无监督学习则主要是对事物本身特性进行分析，一般主要用来进行数据降维和聚类。&emsp;&emsp;分类问题主要是用在预测变量是离散情况的问题上，而预测问题主要是针对预测变量是连续情况的问题。&emsp;&emsp;数据降维主要是对事物的特性进行筛选和压缩。比如处理图片时候，直接利用图像的像素求解问题，那么数据的维度会非常高，因此可以采用数据降维技术对图像进行降维处理，利用最具有区分度的像素对图像进行重组，达到避免维数灾难的效果。&emsp;&emsp;聚类则是依据数据的相似性对数据样本划分成不同的簇。聚类问题不同于分类问题，分类问题中分类的个数和每个分类的含义都是确定的，而聚类问题中簇的个数和每个簇的具体含义是未知的。 1.2 经验&emsp;&emsp;一般把数据看做经验，实际中是对机器学习任务有用的信息才会被看做是经验。通常把反应数据内在规律的信息称作为特征。&emsp;&emsp;监督学习问题中，经验主要包括特征和标签两部分。正常情况下，使用一个特征向量和一个标签来表示一个数据样本。&emsp;&emsp;无监督学习问题中，并没有标签，因此无法进行预测。但是无监督学习对数据结构分析却更胜一筹。在生活中，一般获取的数据都是无标签数据，对数据进行打标签会花费大量的时间、人力等。 1.3 性能&emsp;&emsp;所谓性能，是指学习任务完成质量的评价指标。一般流程是：准备测试样本，使用相同的特征提取方法进行特征提取，然后通过训练好的模型进行预测，对比预测结果和测试样本本身的标签。一般情况下测试样本不用于模型的训练。如果没有单独的测试样本，通常的做法是在原始数据中随机选取3/4作为训练样本，剩余的1/4作为预测样本。通过测试样本正确预测的个数进行准确率的计算。&emsp;&emsp;对于回归问题，通常是将预测值和实际值之间的误差大小作为性能评价指标。&emsp;&emsp;具体的机器学习算法评价指标请参见这里。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>三要素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logistic函数]]></title>
    <url>%2F2017%2F09%2F02%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2FLogistic%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1、Logistic函数推导 &emsp;&emsp;Logistic回归模型中，因变量只有0和1两种情况。假设在$p$个独立自变量${x}_{1}$,${x}_{2}$,…,${x}_{p}$,的作用下，记$y$取1的概率是$p=P(y=1|X)$，则取0的概率是$1-p$。那么取1和取0的概率之比为$\frac{p}{1-p}$，该比值称为发生比（odds）。两个不同时间的发生比之比称为优势比，$\frac{p1}{1-p1}/\frac{p2}{1-p2}$。Logistic一般用发生比odds进行解释。&emsp;&emsp;对发生比取自然对数即为$$Logit(p)=ln(\frac{p}{1-p})$$&emsp;&emsp;令$Logit(p)=Z$，通过化简即可得到$p=\frac{1}{1+e^{-z}}$。$p=\frac{1}{1+e^{-z}}$就是Logistic函数。&emsp;&emsp;因为$p$在$(0,1)$取值，则$Logit(p)$在$(0,+\propto)$取值，Logistic函数在$(-\propto,+\propto)$取值。 2、Logistic回归模型&emsp;&emsp;Logistic回归模型是建立在$ln(\frac{p}{1-p})$与自然变量的线性回归模型。Logistic回归模型的公式为：$$ln(\frac{p}{1-p})={\beta}_{0}+{\beta}_{1}{x}_{1}+…+{\beta}_{p}{x}_{p}+\varepsilon $$&emsp;&emsp;因为$ln(\frac{p}{1-p})$的取值是$(-\propto,+\propto)$,所以自然变量${x}_{1}$,${x}_{2}$,…,${x}_{p}$的取值是任意范围的。&emsp;&emsp;记$g(x)={\beta}_{0}+{\beta}_{1}{x}_{1}+…+{\beta}_{p}{x}_{p}$，得到$p=\frac{1}{1+e^{-g(x)}}$，$1-p=\frac{1}{1+e^{g(x)}}$。此处忽略$\varepsilon$。 3、Logistic回归模型的建模步骤 根据目标数据设置指标变量(因变量、自变量)，然后收集数据。 用$ln(\frac{p}{1-p})$和自变量列出回归方程，估计出模型中的回归系数。$$ln(\frac{p}{1-p})={\beta}_{0}+{\beta}_{1}{x}_{1}+…+{\beta}_{p}{x}_{p} $$ 进行模型检验，根据输出的方差分析表中的$F$值和$p$值来检验该回归方程是否显著。如果$p$值小于显著水平$\alpha$则模型通过检验，可以进行下一步回归系数的检验，否则重新选择指标变量，重新建立回归方程。 在多元线性回归中，并不是每个自变量都会对$y$产生显著的影响，需要对每一个自变量都进行显著性检验，使得那些次要可有可无的变量不参与回归过程，去除之后便可建立更加简单有效的回归方程。 模型应用。 4、对一般Logistic模型系数的解释 该部分引用这里 &emsp;&emsp;广义的线性模型由三部分组成：随机部分、系统部分和连接部分。直观地理解这种差异：将两种模型都视为广义线性模型的特殊形式。广义线性模型由三个部分组成：随机部分、系统部分和连接部分。 &emsp;&emsp;随机部分指的是变量Y以及Y的概率分布，传统线性模型Y是连续变量并假设其服从正态分布。在经典logistic回归中，Y是一个二分变量并服从二项式分布。 &emsp;&emsp;系统部分指的是解释变量以及这些解释变量如何组合在一起构成了解释方程，在传统线性模型和logistic回归中都是这样：${\beta}_{0}+{\beta}_{1}{x}_{1}+…+{\beta}_{p}{x}_{p}$ ，这个表达通常被称为线性预测（linear predictor），而x与其他解释变量还可以结合（如相乘交互），因此可以做出其实非线性的预测。 &emsp;&emsp;连接部分说明了Y的均值 μ =E（Y）如何与线性预测相联系。 其实说白了就是，随机部分规定了 Y，系统部分规定了 X，而连接部分就是用一个连接函数（link function）将 X 与 Y连了起来，也就是我们经常看到的回归方程，它所反映的是 x 的变化带来的 Y 的均值的变化。 &emsp;&emsp;对Logit模型系数解释的一个总的原则是：方向看系数，大小看exp(系数)，不管自变量是连续变量还是虚拟变量 or 其他。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Logistic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据质量分析]]></title>
    <url>%2F2017%2F08%2F30%2F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1. 前言&emsp;&emsp;数据质量分析主要是分析数据源是否含有脏数据。所谓的脏数据是指不符合要求的数据，不能对其进行相应的分析。主要的脏数据有： 缺失值 异常值 不一致的值 重复数据或者含有特殊符号的数据 2. 缺失值分析&emsp;&emsp;缺失值主要包括记录缺失和记录中某项字段信息缺失。使用简单的统计就可以得到含有缺失值的属性个数，以及每个字段的未缺失数、缺失数以及缺失率等。一般情况处理缺失值主要有三种方法： 直接将含有缺失值的记录删除 对缺失值进行插值补充 不处理缺失值 缺失值产生的影响&emsp;1. 数据分析时将会丢失大量的有用信息。&emsp;2. 数据分析模型更难把握数据中蕴含的规律。&emsp;3. 可能会使模型建模陷入混乱，导致错误的输出。 3. 异常值分析&emsp;&emsp;异常值检测是检验数据是否录入错误以及是否含有不合常理的值。异常值是属于个别值，其数值明显偏离其余观测值。因此异常值也成为离群点。一般情况下处理异常值主要有三种方法： 3.1 简单的统计分析&emsp;最常用的统计量就是最大值和最小值。通过最大值和最小值对数据进行判断是否超出了合理的范围。 3.2 $3\sigma$原则&emsp;如果数据服从正态分布，在$3\sigma$原则下，异常值被定义为一组测定值与平均值偏差超过三倍标准差值。$P(|x-\mu|&gt;3\sigma)\leq0.003$属于极个别的小概率事件。 3.3 盒形图分析&emsp;盒形图也称箱形图，提供了识别异常值的一个标准：小于${Q}_{L}-1.5QR$和大于${Q}_{U}-1.5QR$的数据均被认为是异常值，其中$ {Q}_{L}$是下四分位，${Q}_{U}$是上四分位，$ QR={Q}_{U}-{Q}_{L}$。&emsp;四分位数具有一定的鲁棒性，用盒形图分析异常数据的结果比较客观。 4. 一致性分析&emsp;&emsp;不一致是指数据的矛盾性、不相容性。出现这种情况主要是因为待分析的数据来源于不同的数据源或者相同的重复数据没有同步更新，比如数据源中有两张表同时含有用户姓名，更新姓名时候只更新一张表没有更新第二张表则会出现数据不一致性导致数据矛盾不相容。]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于RK3188平台与Android5.1的AP6212蓝牙与wifi调试记录]]></title>
    <url>%2F2017%2F08%2F30%2F%E5%B5%8C%E5%85%A5%E5%BC%8F%2F%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95%2F%E5%9F%BA%E4%BA%8ERK3188%E5%B9%B3%E5%8F%B0%E4%B8%8EAndroid5.1%E7%9A%84AP6212%E8%93%9D%E7%89%99%E4%B8%8Ewifi%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近调试了一款基于RK3188与Android5.1的板子，蓝牙和wifi的芯片采用的是AP6212，AP6212文档在这里。存在的问题是Wifi和蓝牙都不能扫描设备。 1. AP6212管脚图 &emsp;&emsp;管脚10和管脚11是26M晶振的IN和OUT，要求26M晶振的频偏是10ppm。24管脚是32.768KHz晶振的输入脚，如果管脚22（VDD）的幅度为1.8v，则要求24管脚的幅度是1.7v-1.8v，如果管脚22（VDD）的幅度为3.3v，则要求24管脚的幅度是3v-3.3v。通过调整管脚22之前的分压电阻来调整幅度满足要求。通过以上操作可以使得wifi搜的信号，并能连接网络。如果wifi不能工作尝试换一下其他26M晶振。 2. 更新蓝牙固件&emsp;&emsp;经过如上操作，可以使得wifi正常工作，并且蓝牙也能扫描出附近的蓝牙设备，并且能和蓝牙2.0配对，但是不能连接BLE。问题解决办法：联系AP6212的供应商，提供新的AP6212蓝牙固件。对Android5.1系统进行蓝牙固件更新。 2.1 固件更新方法 安装adb调试工具，配置adb.exe的环境变量 将Android5设备与电脑连接 通过adb root获得root权限，执行adb remount push更新固件adb push bcm43438a0.hcd /vendor/firmware/bcm43438a0.hcd 重新启动安卓设备，测试蓝牙连接固件位置要查看android源码进行查找，可以通过locate bt_vendor.conf对配置文件进行定位，比如FwPatchFilePath = /vendor/firmware/]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>RK3188</tag>
        <tag>Wifi</tag>
        <tag>蓝牙</tag>
        <tag>Android5.1</tag>
      </tags>
  </entry>
</search>
